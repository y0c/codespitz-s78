# Code Spitz 디자인 패턴 2

## Design Pattern category 

* 생성패턴 
* 구조패턴 
* 행동패턴

### 객체지향설계를 학습할 수 있는 분류

* 다형성
* 캡슐화 
* 객체관계
* 변화율 
* 역할모델

> 프로그램은 변경될 수 밖에 없다. 
> 대부분의 이유는 **통제할 수 없는 요소임**

제어문 기반의 알고리즘이 갖는 문제 

"수정하면 전체가 컴파일 됨"

개별 알고리즘을 함수로 분리
(프로시저 지향)

### 함수로 분리할떄 문제점 ? 

* case가 변경될때 공통된 데이터가 존재(공통 의존 데이터 문제)
* 상태에 대한 의존성이 강해짐

-> 은닉화와 캡술화를 통해 상태를 직접적으로 접근하지 못하게 막고 메시지를 통해서만 통신하도록 한다. (객체지향의 시작 )

알고리즘 분화시 객체지향에서 선택 할 수 있는 방법 

* 상속 위임(Template Method Pattern)
    * 내부 계약관계로 추상층에서 공통 요소를 해결 상태 공유 가능 
* 소유 위임(Strategy Pattern)
    * 외부계약관계로 각각이 독립적인 문제를 해결 메시지를 주고 받는것으로 문제해결 


### Template Method Pattern vs Strategy Pattern

* Template Method는 상속을 통해서 구현되어있기 때문에 `new`을 통해서 객체 생성 
* Strategy Pattern은 런타임시에 계속해서 변경이 가능하기 떄문에 휴먼에러가 일어날 수 있음 

### 정의 시점에서 제거하는 방법 

* 분기 수만큼 객체를 만들고 
* 실행 시점에 경우의 수를 공급

### 실행시점으로 분기를 옮길 때의 장단점

장점  

1. 정의 시점에 모든 경우를 몰라도 됨 
2. 정의 시점에 그 경우를 처리하는 방법도 몰라도 됨 

> 일정한 통제 범위 내에서 확장가능한 알고리즘설계 가능 

단점 

1. 실행 시점에 모든 경우를 반드시 기술해야함
2. 실행 시점마다 알고리즘의 안정성을 담보해야함 

> 매 호스트코드마다 안정성을 따로 담보해야 됨 
런타임 에러 !! 

### 캡술화 패턴 

* Factory Method Pattern
* Builder Pattern 





