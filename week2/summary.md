# Code Spitz #2
함수의 메모리영역은 인자와 지역변수로 구성 
꼬리물기 최적화는 지역변수 대신 인자로 처리한다. 
인자로 분리할 시 Call Stack을 초기화 해준다. 

## Tail Recursion
* 꼬리물기 최적화를 할때는 기본적으로 상태를 유지하는 것들을 인자로 전달 
* 최적화시에 인자를 통해서 외부변수를 알 수 있다. 
* 꼬리물기 최적화 된 함수는 자연스럽게 루프문과 제어문으로 변경할 수 있음 


## Closure 
함수는 언어에 따라 *문* 과 *값* 으로 구분되어 있음 

## Static State
* 루틴을 *문* 으로 취급함 
* Global 영역과 Local 영역만 컨트롤 가능 
* Java.. 

## Runtime State
* 루틴을 *값* 으로 취급함 
ex) *lambda* 
* 동적으로 루틴을 생성 가능 
* 처음에 Stack 메모리에 올라가있지 않음
* 생성된  환경 *routine* 을 기억하고 있음 (Javascript에서는 scope)

> 컨텍스트(Context)
> 루틴이 생성된 환경을 컨텍스트라고 한다. 

> 자유변수 (Free Variable)
> 현재 루틴에 존재하지 않고 상위 Flow에 존재하는 변수를 뜻함 
> 즉, 현재 스코프에 존재하지 않는 변수 
> *자유변수는 루틴에서 사용될시 해제되지 않는다.* 

> 클로저(Closure) 
> 클로저는 자유변수를 포함하고 있는 영역이다. 

*런타임에 루틴을 만들 수 있는 영역은 자유변수가 존재하고 자유변수가 존재하면 클로저가 발생할 수 밖에없다.* 


## Nested Clousre 
ES6 이전에 클로저는 루틴에 의해서만 생성됨. 
하지만 ES6에서는 let, const등도 *Block Scope*를 생성하게 된다. 
단지 중괄호를 사용하는 것으로 *Block* 을 생성하게 된다. 

> 쉐도잉(Shadowing)
> 중첩된 클로저에서 같은 이름의 변수를 의미한다. 
> 대부분의 언어에서는 가장 가까운 클로저의 변수를 참조하게 된다. 
> 현재 스코프 위로는 가려진다는 의미를 내포 

/중첩된 클로저 에서 자유변수를 오염시키지 않는 유일한 방법은 Shadowing 이다./ 

## Co Routine 
제어문 -> 명령어 
Flow는 한 번 실행되면 멈출수 없음. 
명령어 한 줄 한 줄을 *서브 루틴* 으로 만들면 ? 
루틴을 중간에 중단시키는 작업이 가능해짐 

-> Javascript 에서는 Co Rutine을 *Generator*로 사용가능함 

* *return* 대신 *yield* 키워드 제공 
* *yield* 문은   *suspension* 을 걸 수 있음 

공유해야할 *상태*가 점점 많아질 경우 *코루틴*을 사용하면 인자를 사용하지않고 
지역변수를 통해서 공유할 수 있으므로 코드 가독성이 높아지게 된다. 


### Generator 
제네레이터 자체는 *코루틴*을 만드는 역활을 하게됨. 
*next* 메소드를 호출함으로 *코루틴*을 진행시킬 수 있음 
